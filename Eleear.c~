#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <linux/fb.h>
#include <sys/mman.h>
#include <math.h>

#define INT8U      unsigned char
#define INT16U     unsigned int
#define INT32U	   unsigned long
#define INT8S      signed   char
#define INT16S	   signed   int
#define INT32S     signed   long*/
#define XMAX	800
#define YMAX	480

// 'global' variables to store screen info

char *fbp = 0;
struct fb_var_screeninfo vinfo;
struct fb_fix_screeninfo finfo;

//extern INT8U Arial18h[];

//extern INT8U Century_Schoolbook114h[];
//extern const char Arial18h[] __attribute__((aligned(2)));

INT8U keysay,status,dummy,pre_button;
INT16U FFTVal[128];

//////////////////////////////////////////////////////////
#define BCM2708_PERI_BASE       0x20000000
#define GPIO_BASE               (BCM2708_PERI_BASE + 0x200000)	// GPIO controller 
 
#define BLOCK_SIZE 		(4*1024)
// IO Acces
struct bcm2835_peripheral 
{
    unsigned long addr_p;
    int mem_fd;
    void *map;
    volatile unsigned int *addr;
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct bcm2835_peripheral gpio = {GPIO_BASE};
 
// Exposes the physical address defined in the passed structure using mmap on /dev/mem
int map_peripheral(struct bcm2835_peripheral *p)
{
   // Open /dev/mem
   if ((p->mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
      printf("Failed to open /dev/mem, try checking permissions.\n");
      return -1;
   }
 
   p->map = mmap(
      NULL,
      BLOCK_SIZE,
      PROT_READ|PROT_WRITE,
      MAP_SHARED,
      p->mem_fd,      // File descriptor to physical memory virtual file '/dev/mem'
      p->addr_p       // Address in physical map that we want this memory block to expose
   );
 
   if (p->map == MAP_FAILED) 
   {
        perror("mmap");
        return -1;
   }
 
   p->addr = (volatile unsigned int *)p->map;
 
   return 0;
}
 
void unmap_peripheral(struct bcm2835_peripheral *p) 
{
    munmap(p->map, BLOCK_SIZE);
    close(p->mem_fd);
}
///////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
// GPIO setup macros. Always use INP_GPIO(x) before using OUT_GPIO(x)
#define INP_GPIO(g)   *(gpio.addr + ((g)/10)) &= ~(7<<(((g)%10)*3))
#define OUT_GPIO(g)   *(gpio.addr + ((g)/10)) |=  (1<<(((g)%10)*3))
#define SET_GPIO_ALT(g,a) *(gpio.addr + (((g)/10))) |= (((a)<=3?(a) + 4:(a)==4?3:2)<<(((g)%10)*3))
 
#define GPIO_SET  *(gpio.addr + 7)  // sets   bits which are 1 ignores bits which are 0
#define GPIO_CLR  *(gpio.addr + 10) // clears bits which are 1 ignores bits which are 0
 
#define GPIO_READ(g)  *(gpio.addr + 13) &= (1<<(g))
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define BSC0_BASE     (BCM2708_PERI_BASE + 0x205000)  // I2C controller 
#define BSC1_BASE     (BCM2708_PERI_BASE + 0x804000)  // I2C controller 

struct bcm2835_peripheral bsc1;	
 
// I2C macros
#define BSC1_C          *(bsc1.addr + 0x00)
#define BSC1_S          *(bsc1.addr + 0x01)
#define BSC1_DLEN     *(bsc1.addr + 0x02)
#define BSC1_A          *(bsc1.addr + 0x03)
#define BSC1_FIFO     *(bsc1.addr + 0x04)
 
#define BSC_C_I2CEN     (1 << 15)
#define BSC_C_INTR      (1 << 10)
#define BSC_C_INTT      (1 << 9)
#define BSC_C_INTD      (1 << 8)
#define BSC_C_ST        (1 << 7)
#define BSC_C_CLEAR     (1 << 4)
#define BSC_C_READ       1
 
#define START_READ      BSC_C_I2CEN|BSC_C_ST|BSC_C_CLEAR|BSC_C_READ
#define START_WRITE     BSC_C_I2CEN|BSC_C_ST
 
#define BSC_S_CLKT    (1 << 9)
#define BSC_S_ERR     (1 << 8)
#define BSC_S_RXF     (1 << 7)
#define BSC_S_TXE     (1 << 6)
#define BSC_S_RXD     (1 << 5)
#define BSC_S_TXD     (1 << 4)
#define BSC_S_RXR     (1 << 3)
#define BSC_S_TXW     (1 << 2)
#define BSC_S_DONE    (1 << 1)
#define BSC_S_TA       1
 
#define CLEAR_STATUS    BSC_S_CLKT|BSC_S_ERR|BSC_S_DONE

//////////////////////////////////////////////////////////////

void wait_i2c_done();
void UpdateADCNumberScreen( INT16U val);

INT8U Key, KeyPressed ;
INT32U num;


INT16U ADC_Val;
INT8U adccal_flag;

typedef void(*Ptr2fun)(void);
/*--------------------------------- Data Structures for Interaction Manager ---------------------------------*/

INT8U GetKey(void);
INT8U GetAdc(void);
//////////////////////////////                         /////////////////////////////////////

// helper function to 'plot' a pixel in given color

void put_pixel(int pix_x, int pix_y, int c)
{
    // calculate the pixel's byte offset inside the buffer
    unsigned int pix_offset = pix_x + pix_y * finfo.line_length;
    // now this is about the same as 'fbp[pix_offset] = value'
    *((char*)(fbp + pix_offset)) = c;
}

void clearscreen(int colour) 
{
    int x, y;
    for (y = 0; y < (vinfo.yres); y++) 
    {
        for (x = 0; x < vinfo.xres; x++) 
	{   // color based on the 16th of the screen width
            int c = colour;
            // call the helper function
            put_pixel(x, y, c);
        }
    }
}

// helper function for drawing - no more need to go mess with
// the main function when just want to change what to draw...
void draw() 
{
    int x, y;
    for (y = 0; y < (vinfo.yres); y++) 
    {
        for (x = 0; x < vinfo.xres; x++) 
	{   // color based on the 16th of the screen width
            int c = 16 * x / vinfo.xres;
            // call the helper function
            put_pixel(x, y, c);
        }
    }
}

int Line(INT16U x1, INT16U y1, INT16U x2, INT16U y2 ,int color)
{
    INT16S   deltaX, deltaY, error, stepErrorLT, stepErrorGE, stepX, stepY, steep, temp, slope;
    INT8U    lineType = 0,lineThickness = 1;
    INT16U   style = 0 , type = 1;
    //MoveTo(x2, y2);
	unsigned int pix_offset = x2 + y2 * finfo.line_length;
	if(x1 == x2)
   	{ 
	if(y1 > y2)
        {
            temp = y1;
            y1 = y2;
            y2 = temp;
        }
        style = 0; type = 1;
        for(temp = y1; temp < y2 + 1; temp++)
        {
            if((++style) == lineType)
            {
             //   type ^= 1;
              //  style = 0;
            }
            if(type)
            {
                put_pixel(x1, temp,color);
                if(lineThickness)
                {
                    put_pixel(x1 + 1, temp,color);
                    put_pixel(x1 - 1, temp,color);
                }
            }
        } return (1);
    }
    if(y1 == y2)
    {
        if(x1 > x2)
        {
            temp = x1; x1 = x2; x2 = temp;
        }
        style = 0;
        type = 1;
        for(temp = x1; temp < x2 + 1; temp++)
        {
            if((++style) == lineType)
            {
                //type ^= 1;
                //style = 0;
            }

            if(type)
            {
                put_pixel(temp, y1,color);
                if(lineThickness)
                {
                    put_pixel(temp, y1 + 1,color);
                    put_pixel(temp, y1 - 1,color);
                }
            }
        }
        return (1);
    }
    stepX = 0;
    deltaX = x2 - x1;
    if(deltaX < 0)
    {
        deltaX = -deltaX;
        --stepX;
    }
    else
    {
        ++stepX;
    }
    stepY = 0;
    deltaY = y2 - y1;
    if(deltaY < 0)
    {
        deltaY = -deltaY;
        --stepY;
    }
    else
    {
        ++stepY;
    }
    steep = 0;
    if(deltaX < deltaY)
    {
        ++steep;
        temp = deltaX;
        deltaX = deltaY;
        deltaY = temp;
        temp = x1;
        x1 = y1;
        y1 = temp;
        temp = stepX;
        stepX = stepY;
        stepY = temp;
        put_pixel(y1, x1,color);
    }
    else
    {
        put_pixel(x1, y1,color);
    }
    // If the current error greater or equal zero
    stepErrorGE = deltaX << 1;
    // If the current error less than zero
    stepErrorLT = deltaY << 1;
    // Error for the first pixel
    error = stepErrorLT - deltaX;
    style = 0;
    type = 1;
    while(--deltaX >= 0)
    {
        if(error >= 0)
        {
            y1 += stepY;
            error -= stepErrorGE;
        }
        x1 += stepX;
        error += stepErrorLT;
        if((++style) == lineType)
        {
            //type ^= 1;
            //style = 0;
        }
        if(type)
        {
            if(steep)
            {
                put_pixel(y1, x1,color);
                if(lineThickness)
                {
                    put_pixel(y1 + 1, x1,color);
                    put_pixel(y1 - 1, x1,color);
                }
            }
            else
            {
                put_pixel(x1, y1,color);
                if(lineThickness)
                {
                    put_pixel(x1, y1 + 1,color);
                    put_pixel(x1, y1 - 1,color);
                }
            }
        }
    }   // end of while
    return (1);
}

int Bar(INT16U left, INT16U top, INT16U right, INT16U bottom,INT8U color)
{
    INT16U   x, y;
    {
        for(y = top; y < bottom + 1; y++)
        for(x = left; x < right + 1; x++)
        put_pixel(x, y,color);
    }
    return (1);
}


int Grid( INT16U x1, INT16U y1,INT16U x2,INT16U y2, INT16U xdiv, INT16U ydiv, INT8U color)
{
	Bar(x1,y1,x2,y2,7);
	INT16U x,y;
	for( x = x1+xdiv ; x < x2 ;x+=xdiv)
	{
		Line(x,y1,x,y2,color);
	}
	for(y = y1+ydiv ; y < y2;y+=ydiv)
	{
		Line(x1,y,x2,y,color);
	}
	return 1;
}

int BarGraph(INT8U value,INT16U no ,INT16U x1,INT16U y1, INT16U x2,INT16U y2,INT8U color)
{
	INT16U xvar,yvar,x,i;
	Bar(x1,y1,x2,y2,color);
	xvar = ((x2 - x1)/(no*2));
	for(x = x1,i = 0 ; x < x2,i < no ; x += (xvar*2),i++)
	{
		Bar(x,y2 - value,x+xvar,y2,color+1);//Bar(x,y2 - value[i],x+xvar,y2,valcolor[i]);
	}
}



INT8U GetFFT()
{	INT32U status;
	INT16U i ;
	BSC1_A = 0x7;
	INP_GPIO(25);
	usleep(5);   
	status = GPIO_READ(25);
	if(status == 0)
	{
		for( i = 0 ; i < 128 ; i++ )
		{
			BSC1_DLEN = 1;
			BSC1_S = CLEAR_STATUS;  // Reset status bits
			BSC1_C = START_READ;    // Start Read after clearing FIFO
			wait_i2c_done();
			FFTVal[i] = BSC1_FIFO;
			printf("FFT[%d] = %d\n",i, FFTVal[i]);
			//return keysay;
		}
	}
	else {printf("FFT Not Ready Yet");}//return 0;
}


//////////////////////////////////////////////////////////////////////////////////////
// I2C Function Prototypes
void i2c_init();
struct bcm2835_peripheral bsc1 = {BSC1_BASE};
 
// Initialize I2C
void i2c_init()
{
    INP_GPIO(2);
    SET_GPIO_ALT(2, 0);
    INP_GPIO(3);
    SET_GPIO_ALT(3, 0);
}  
 
// Function to wait for the I2C transaction to complete
void wait_i2c_done() 
{
        int timeout = 50;
        while((!((BSC1_S) & BSC_S_DONE)) && --timeout) {
            usleep(1000);
        }
        if(timeout == 0)
            printf("Error: wait_i2c_done() timeout.\n");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

// application entry point
int main(void)
{
    INT32U drx,dry, i;
    int fbfd = 0;
    struct fb_var_screeninfo orig_vinfo;
    long int screensize = 0;

    if(map_peripheral(&gpio) == -1) {
        printf("Failed to map the physical GPIO registers into the virtual memory space.\n");
        return -1;
    }
    if(map_peripheral(&bsc1) == -1) {
        printf("Failed to map the physical BSC1 (I2C) registers into the virtual memory space.\n");
        return -1;
    }

    // Open the file for reading and writing
    fbfd = open("/dev/fb0", O_RDWR);
    if (!fbfd) {
      printf("Error: cannot open framebuffer device.\n");
      return(1);
    }
    printf("The framebuffer device was opened successfully.\n");

    // Get variable screen information
    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &vinfo)) {
      printf("Error reading variable information.\n");
    }
    printf("Original %dx%d, %dbpp\n", vinfo.xres, vinfo.yres, 
       vinfo.bits_per_pixel );

    // Store for reset (copy vinfo to vinfo_orig)
    memcpy(&orig_vinfo, &vinfo, sizeof(struct fb_var_screeninfo));

    // Change variable info
    vinfo.bits_per_pixel = 8;
    if (ioctl(fbfd, FBIOPUT_VSCREENINFO, &vinfo)) {
      printf("Error setting variable information.\n");
    }

    // Get fixed screen information
    if (ioctl(fbfd, FBIOGET_FSCREENINFO, &finfo)) {
      printf("Error reading fixed information.\n");
    }

  // map fb to user mem 
    screensize = vinfo.xres * vinfo.yres;
    fbp = (char*)mmap(0, 
              screensize, 
              PROT_READ | PROT_WRITE, 
              MAP_SHARED, 
              fbfd, 
              0);

    if ((int)fbp == -1) {
        printf("Failed to mmap.\n");
    }
    else {
                 
        i2c_init();
	/*clearscreen(0);
	get_reading();
	Grid(50,50,450,350,40,30,8);
	Plotgraph(50,350,1,1,450,350,4);
	BarGraph(8,50,360,450,460,7);
	DrawMeter(460,50,790,250,50,10,4);
	outtext_xy((INT16U)600,(INT16U)300,(INT8U)4,(INT8U)7,(INT8U *)str1,(INT8U *)Arial18h,(INT8U)TRANSPARENT);
	//sleep(5);
	outtext_xy(500,350,4,7,(INT8U *)str2,(INT8U *)Arial18h,NONTRANSPARENT);
	//sleep(25);
	getchar();

	clearscreen(0);
	Bar(5,5,785,475,7);:
	Bar(20,20,100,70,0);
	Bar(22,22,98,68,7);
	
	Bar(15,100,85,472,0);
	Bar(17,102,83,470,7);
	Line(35,100,35,472,0);
	Bar(17,102,34,200,6);

	DrawBakerBar(0,0,100,480);
*/

	while(1)
	{
		GetFFT();
	}
	
    }		
    unmap_peripheral(&gpio);
    unmap_peripheral(&bsc1);
    // cleanup
    munmap(fbp, screensize);
    if (ioctl(fbfd, FBIOPUT_VSCREENINFO, &orig_vinfo)) {
        printf("Error re-setting variable information.\n");
    }
 //   close(fbfd);

    return 0;
  
}

